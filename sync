#!/usr/bin/env bash

# Enable error checking.
set -e

if [[ "$1" == "-h" || "$1" == "--help" ]]; then cat <<HELP
Usage: $(basename "$0") [-h --help] [-c --copy]

If run without arguments, it will symbolically link the dotfiles in this
repository to your $HOME directory. This means that the original files have
to be stored in the repository, while the files in $HOME will be links (aka
pointers). The reason we do it this way is because tracking and hosting a
bunch of absolute paths to files is rather useless.

Use the --copy or -c flag to copy your list of specified dotfiles from $HOME
to this repository. It will first remove all dotfiles from the repository.
It won't stage your dotfiles or commit them. Come to think of it, this function
isn't very useful.

See the README for documentation.  https://github.com/dideler/dotfiles#readme

Copyright (c) 2012-2013 Dennis Ideler
Licensed under the MIT license.
HELP
exit; fi

# Fancy logging (inspired by @cowboy).
# Quotation marks for string arguments optional, but preferred.
print_info()   { echo -e "\n \033[1;36m❗\033[0m $@\033[0m"; }
print_prompt() { echo -e " \033[1;34m?\033[0m  $@"; }
print_pass()   { echo -e " \033[1;32m✔\033[0m  $@"; }
print_fail()   { echo -e " \033[1;31m✗\033[0m  $@"; }
print_link()   { echo -e " \033[1;33m➜\033[0m  $@"; }

unhide() {
  # Remove the leading dot from all hidden files and dirs, except .git and .gitignore.
  find . \( -iname ".*" ! -iname ".git" ! -iname ".gitignore" \) -print0 | xargs -r0 rename -v 's|/\.+([^/]+)$|/$1|'
}

# $1 is the original file.
# $2 is the pointer.
# Must use full path.
link() {
  #ln -sf "$1" "$2"
  echo $(readlink $1) -> $(readlink $2)
  # can also use ln -s "$(pwd)/$file" "$dest" instead of readlink
  print_success "Link $1 to $2"
  # TODO test
  # $(ln --symbolic $force_flag $(pwd)/dotfile ~/)
  # i.e. does dest have to be full path? i don't think so!
}

clean_repo() {
  find . -not -name 'README' -not -name 'LICENSE' -not -name 'sync' -delete
  print_success "Repository cleaned"
}

# TODO: reconsider adding this function. is it useful? may be better to do manually
# Copies whatever dotfiles you specified here from $HOME to your dotfiles repo.
# This function should come in handy for users who are new to having a dotfiles repo.
# Use this when your dotfiles repo is empty and all your dotfiles are still in $HOME.
copy_dotfiles() {
  print_info "Copying dotfiles"
  #clean_repo
  # Copy the desired dot files to this directory.
  #rsync --relative --archive --verbose --update --no-perms \
  #      ~/.{bash_aliases,vimrc,gitconfig,config/fish/config.fish,config/fish/functions/} \
  #      ~/.{vim/plugin/,vim/syntax/,ssh/config*,weechat/*.conf,config/redshift.conf} .
  # Get rid of the /home/user/ path by moving all files out of there and deleting the directory.
  #rsync --archive --remove-source-files ./home/$(whoami)/ .
  #rm -rf ./home
}

# TODO maybe better to not stage sensitive files?
hide_sensitive_info() {
  echo
  #sed -i 's/password = .*$/password = --redacted--/' irssi/config # irc pass
  #sed -i 's|password = .*S|password = ""|' weechat/irc.conf # freenode.sasl_password
}

# Symbolically links files in your dotfiles repo to your $HOME.
# For example, if your dotfiles repo has a file named '.foo',
# this will create a pointer: $HOME/.foo ➜ ~/path/to/dotfiles/.foo
link_dotfiles() {
  print_bold "Installing dotfiles"
  #DOTFILES_ROOT=$(pwd)
  local dotfiles=$(find -name '.*')
  for file in $dotfiles; do
    echo $file
  done
  # TODO
  # for every *dotfile* in repo
  #   create link in home    
}

run_tests() {
  print_info foo bar
  print_prompt foo bar
  print_pass foo bar
  print_fail foo bar
  print_link foo bar

  echo "flag has value $force_flag"
}

force_flag=""

if [[ "$1" == "-f" || "$1" == "--force" ]]; then
  force_flag="--force"
  print_info "Force flag set. Existing destination files will be removed when creating symbolic links."
fi

run_tests
# TODO: link_dotfiles
